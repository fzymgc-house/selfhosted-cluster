
# Kubernetes Rules

## Application Structure

### Directory Organization
- Organize applications in logical groups under `apps/`
- Each application should have its own directory with a `kustomization.yaml`
- Use consistent naming: `apps/{category}/{application-name}/`

### Kustomization Files
- Every directory with Kubernetes resources needs a `kustomization.yaml`
- List resources in logical order (namespace first, then configs, then deployments)
- Use standard format with `apiVersion: kustomize.config.k8s.io/v1beta1`

## Kubernetes Resources

### Namespaces
- Create namespace.yaml as first resource in each app directory
- Keep it simple with just name and optional labels

### Helm Charts
- Use standard Helm charts with `helm install` or `kubectl apply`
- Always specify chart version explicitly
- Include proper values files for customization
- Use Helm repositories for chart sources

### HelmRepository Resources
- Place in `infrastructure/controllers/helm-repositories/`
- Use standard Helm repository configuration
- Set appropriate intervals (usually 1h)

## Kubernetes Resources

### Namespaces
- Create namespace.yaml as first resource in each app directory
- Keep it simple with just name and optional labels

### Kustomization Files
- Every directory with Kubernetes resources needs a `kustomization.yaml`
- List resources in logical order (namespace first, then configs, then deployments)
- Use standard format with `apiVersion: kustomize.config.k8s.io/v1beta1`

### Certificates (cert-manager)
- Use `apiVersion: cert-manager.io/v1`
- Reference appropriate issuer (fzymgc-house-issuer for internal)
- Standard duration and renewal settings

### External Secrets
- Use `apiVersion: external-secrets.io/v1`
- Reference the vault ClusterSecretStore
- Use templating for secret structure

### Traefik IngressRoutes
- Use `apiVersion: traefik.io/v1alpha1`
- Always use TLS with proper certificates
- Include middleware when needed

## Resource Patterns

### Multi-Resource Files
- Separate resources with `---`
- Order: Namespace → ConfigMaps/Secrets → Deployments → Services → Ingress

### Labels and Annotations
- Use consistent labels following Kubernetes conventions
- Include app.kubernetes.io/* labels

### Resource Limits
- Always set resource requests and limits when known
- Use appropriate CPU and memory values
- Consider storage requirements for stateful services

### Storage
- Use appropriate storage classes:
  - `longhorn`: Standard replicated storage
  - `longhorn-encrypted`: Encrypted storage for sensitive data
  - `postgres-storage`: Optimized for PostgreSQL workloads

## Application Deployment

### Manual Deployment
- Use `kubectl apply -k` for Kustomization-based deployments
- Use `helm install/upgrade` for Helm chart deployments
- Always validate manifests with `--dry-run=client` first

### State Management
- Use appropriate controllers for different workload types
- Implement proper backup strategies for stateful services
- Use ConfigMaps and Secrets for configuration

## Best Practices
1. Always use explicit API versions (no shortcuts)
2. Set proper health checks and probes
3. Use anti-affinity rules for HA deployments
4. Implement proper RBAC for service accounts
5. Use NetworkPolicies for service isolation
6. Set PodDisruptionBudgets for critical services
7. Use topologySpreadConstraints for even distribution
8. Implement proper backup strategies for stateful services

8. Implement proper backup strategies for stateful services

7. Use topologySpreadConstraints for even distribution
8. Implement proper backup strategies for stateful services
